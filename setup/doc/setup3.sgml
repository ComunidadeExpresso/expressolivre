<!doctype article public "-//OASIS//DTD DocBook V3.1//EN"
 [ <!entity header system "header.sgml">
 
]>

<article lang="en">
<!-- DocBook file was created by LyX 1.1
  See http://www.lyx.org/ for more information -->
  <artheader>
   <title>
   eGroupWare Setup
  </title>
  <date>
   June 18, 2001 
  </date>
  <author>
   <firstname>Miles</firstname> <surname>Lott</surname>
  </author>
  <abstract>
  <para>
   A developer introduction to using the next generation setup application for egroupware.
  </para>
  </abstract>
  </artheader>
  <sect1>
   <title>
   Introduction
  </title>
   <sect2>
    <title>
    Welcome
   </title>
   <para>
    Thanks for taking the time to look over this document. If you are a developer who is new to egroupware, this document will be invaluable to your success during the life of your application. This is in addition to the other fine documentation available in the phpgwapi/doc directory in your install. Even long-time phpgw developers should benefit this document. Herein, I will attempt to outline the critical steps required in order to get along with setup3, setup-TNG, or whatever we end up calling it (Hey, how about 'setup'?)
   </para>
   </sect2>
   <sect2>
    <title>
    Overview
   </title>
   <para>
    With setup3, we introduce several new capabilities and technologies for the developer and end user alike. Michael Dean was kind enough to offer up schema_proc to form the core of an abstracted and database-independent upgrade process. This enables developers to write a single set of upgrades and table definitions, which should then work on MySQL and PostgreSQL, or any other database type we might add in the future.
   </para>
   <para>
    Adding to this to control the process was a good chunk of the old setup program, written by Dan Kuykendall (Seek3r). Dan had everything to do with the new dependencies support and with the format of the &dollar;setup_info array in setup3.
   </para>
   <para>
    Setup3 adds multi-language support for the setup application, a long missed feature, I would imagine.
   </para>
   <para>
    Setup3 gives each application developer control over their application install and upgrade processes, while giving them access to work within a realm formerly owned by only the former core egroupware applications. Yes, this is extra work for the developer. But it is hoped that setup3 is also viewed as a tool that can truly enhance the development process.
   </para>
   <para>
    OK. Let's dive right in...
   </para>
   </sect2>
  </sect1>
  <sect1>
   <title>
   Application setup files
  </title>
  <para>
   The files in this section are contained within each application/setup directory. Every app will some of these files in order to operate with setup3.
  </para>
   <sect2>
    <title>
    setup.inc.php (Required)
   </title>
    <sect3>
     <title>
     Basic information
    </title>
    <para>
     The values in this section must be used by all applications.
    </para>
    <para>
     The first section of setup.inc.php defines the very basic and yet critical information about the application. Take a look at the following section:
    </para>
    <programlisting>
<![ CDATA [$setup_info['addressbook']['name'] = 'addressbook';
]]><![ CDATA [$setup_info['addressbook']['title'] = 'Addressbook';
]]><![ CDATA [$setup_info['addressbook']['version'] = '0.9.13.002';
]]><![ CDATA [$setup_info['addressbook']['app_order'] = 4;
]]><![ CDATA [$setup_info['addressbook']['enable'] = 1;
]]>    </programlisting>
    <para>
     'name' is used throughout egroupware, typically in &dollar;phpgw_info flags such as 'currentapp' or as the 'app_name' almost everywhere else.
    </para>
    <para>
     'title' would be used in the navbar, admin, preferences, as well as in the application itself.
    </para>
    <para>
     The 'version' string defines the version of the application and table code. This would be incremented whenever you create a new upgrade function, and typically only for table modifications. If the change is significant from the last code update, you could increment this here also. Incrementing this version string is not trivial, so please do read the rest of this document for more information about that.
    </para>
    <para>
     'app_order' determines the order of applications in the navbar. If the number you set here is the same as is set for another app, the app whose 'name' is first in the English alphabet would appear first. Smaller numbers show closer to the top or left end of the navbar, depending upon the layout.
    </para>
    <para>
     The 'enable' string is used by the egroupware API to determine whether an application is disabled, enabled, or enabled but hidden from the navbar. Most applications will want this set to a value of 1 (enabled). The notifywindow app sets this to 2, which keeps it off the navbar. An enable of 0 would disable the app by default. There is one other special case, 3, which is used primarily by the API itself. From the perspective of setup3, the API is an application just like any other application. By setting the 'enable' flag to 3, the API is still enabled, but will not be assignable to a user as a real application. It will thereby be hidden from the admin for application and user/group editing.
    </para>
    </sect3>
    <sect3>
     <title>
     Table info
    </title>
     <sect4>
      <title>
      Only applications with database tables will use entries in this section.
     </title>
     <para>
      The next section of &dollar;setup_info values is an array defining all of the application's database tables:
     </para>
     <programlisting>
<![ CDATA [$setup_info['addressbook']['tables'] = array(
]]><![ CDATA [    'phpgw_addressbook',
]]><![ CDATA [    'phpgw_addressbook_extra'
]]><![ CDATA [);
]]>     </programlisting>
     <para>
      This is a simple array, and must list accurately the current table names you are using in your application. This list will match a much more complex array of table specifications, as you will see below.
     </para>
     </sect4>
    </sect3>
    <sect3>
     <title>
     Hooks
    </title>
     <sect4>
      <title>
      Some applications will use this section.
     </title>
     <para>
      The hooks array part of &dollar;setup_info contains a simple list of hooks the application will use:
     </para>
     <programlisting>
<![ CDATA [$setup_info['addressbook']['hooks'][] = 'preferences';
]]><![ CDATA [$setup_info['addressbook']['hooks'][] = 'admin';
]]>     </programlisting>
     <para>
      Here we also note a different method of 'stuffing the array.' In any case, this list of hooks will be required soon in order for your hook_admin.inc.php and other files to work. This is being done to cut down on the manual directory listing and file_exists loops done currently to discover hook files. Other than 'preferences' and 'admin', 'home', 'manual', 'after_navbar' and 'navbar_end' are all valid hook entries.
     </para>
     </sect4>
    </sect3>
    <sect3>
     <title>
     Dependencies
    </title>
     <sect4>
      <title>
      All applications will have at least one entry here.
     </title>
     <para>
      The final section, or array of data, is a listing of the other applications your application requires in order to function:
     </para>
     <programlisting>
<![ CDATA [$setup_info['addressbook']['depends'][] = array(
]]><![ CDATA [    'appname' => 'phpgwapi', 
]]><![ CDATA [    'versions' => Array(
]]><![ CDATA [        '0.9.10',
]]><![ CDATA [        '0.9.11',
]]><![ CDATA [        '0.9.12',
]]><![ CDATA [        '0.9.13'
]]><![ CDATA [    ) 
]]><![ CDATA [);
]]>     </programlisting>
     <para>
      This is the standard dependency array for all egroupware applications. It states that this application requires the phpgwapi, and lists the versions with which versions this app is compatible. This list would need to be appended upon each new API release, assuming your application is compatible with this new API version. You may list other applications here, e.g. your app might depend upon 'email' in order to work properly.
     </para>
     <para>
      Do NOT list applications here without considering this: If you do list an application here, and your app does not really require it, your application will not install unless that other application is already installed. This is handled normally within the install/upgrade process loops, which will install only applications whose dependencies are satisfied. Using a multipass function, the applications are installed in the correct order to ensure that dependencies are resolved. In all cases, the API would be installed first in every new install or upgrade, since all applications depend on the API.
     </para>
     </sect4>
    </sect3>
   </sect2>
   <sect2>
    <title>
    tables_baseline.inc.php (Recommended)
   </title>
    <sect3>
     <title>
     Any application that has at least one upgrade routine will have this file.
    </title>
    <para>
     The tables_baseline file represents the earliest supported version of an application's tables. This file is used only in the upgrade process, and is critical to its success. It contains an array of database-independent table, field, key and index definitions.
    </para>
    <para>
     This array is formatted for use by the class.schema_proc_array.inc.php file in setup3. See the tables_update section below for more detail about schema_proc, but for now, here is a simple table definition in this format:
    </para>
    <programlisting>
<![ CDATA [$phpgw_baseline = array(
]]><![ CDATA [    'skel' => array(
]]><![ CDATA [        'fd' => array(
]]><![ CDATA [            'skel_id' => array('type' => 'auto','nullable' => false),
]]><![ CDATA [            'skel_owner' => array('type' => 'varchar','precision' => 25),
]]><![ CDATA [            'skel_access' => array('type' => 'varchar','precision' => 10),
]]><![ CDATA [            'skel_cat' => array('type' => 'int','precision' => 4),
]]><![ CDATA [            'skel_des' => array('type' => 'text'),
]]><![ CDATA [            'skel_pri' => array('type' => 'int','precision' => 4)
]]><![ CDATA [        ),
]]><![ CDATA [        'pk' => array('skel_id'),
]]><![ CDATA [        'fk' => array(),
]]><![ CDATA [        'ix' => array(),
]]><![ CDATA [        'uc' => array()
]]><![ CDATA [    ) 
]]><![ CDATA [);
]]>    </programlisting>
    <para>
     This multi-dimensional array contains 1 subarray with 5 subs of its own. The first array ('skel' above) defines the table name. Below that are 5 sections, 'fd' for field definitions, 'pk' to define primary keys, 'fk' to define foreign keys, 'ix' to define indexed fields, and 'uc' to define columns that require unique values. In the above example, the table 'skel' has 6 fields (skel_id, skel_owner, skel_access, skel_cat, skel_des, skel_pri), and 'skel_id' is defined also as the primary key for this table. More information on this array is below. But, this format was chosen as an available solution for defining tables and fields without having to maintain seperate files for different databases.
    </para>
    </sect3>
   </sect2>
   <sect2>
    <title>
    tables_current.inc.php (Recommended)
   </title>
    <sect3>
     <title>
     All applications with tables will need this file.
    </title>
    <para>
     The tables_current file defines the current table definition that matches the 'version' string in &dollar;setup_info as well as the current code. This file is used only for new installs, or whenever the application is removed and reinstalled. The format and name of the array in this file is the same as for the tables_baseline file listed above. In fact, whenever it is required to change your table definitions, you would start by copying the current file over to become the tables_baseline file. After having created your upgrade routines, you would then recreate the current file to match the new table definitions.
    </para>
    </sect3>
   </sect2>
   <sect2>
    <title>
    tables_update.inc.php (Recommended)
   </title>
    <sect3>
     <title>
     Any application which requires an upgrade to a previous version's tables will need this file.
    </title>
    <para>
     This file will be the most complex of all setup-oriented files with which you will be working. It will contain all upgrade functions capable of upgrading any possible version of your egroupware app. These upgrade routines roughly match the old setup program's upgrade functions, but the use of objects and the methods have changed dramatically. The simplest version upgrade routine would look like:
    </para>
    <programlisting>
<![ CDATA [$test[] = "0.9.3pre10";
]]><![ CDATA [function addressbook_upgrade0_9_3pre10()
]]><![ CDATA [{
]]><![ CDATA [    global $setup_info;
]]><![ CDATA [    $setup_info['addressbook']['currentver'] = '0.9.3';
]]><![ CDATA [    return $setup_info['addressbook']['currentver'];
]]><![ CDATA [}
]]>    </programlisting>
    <para>
     This upgrade function merely updates the current version number. Note that there is not only an upgrade function, but also the setting of a value in the &dollar;test array. The name 'test' is a holdover from the old setup program, and is an arbitrary choice. However, this name must be used for the upgrade process to work. Prior to each of your upgrade functions, add the value of the previous version to &dollar;test.
    </para>
    <para>
     Now look at the function name. The name is important and should be structured as the application name and the version from which you are intending to upgrade. The '.'s in the version string are replaced with '_'.
    </para>
    <para>
     Inside the function, we global the &dollar;setup_info array. Next, we alter the version number in that array, for our application. Please be careful to specify YOUR application name here. The very last thing we do is to return this new version to the calling function. The upgrade process relies on the value returned, since it uses this directly to determine the new version. This may appear illogical on some level, but it does work. The reason for returning this value instead of a True or 1, etc. has to do with variable scope and lifetime. In this way, even the globaling of &dollar;setup_info inside the function may have little effect on the upgrade process. But, there may be values in this array you would want to use within the function. More on that later.
    </para>
    <para>
     There is one other variable you would need if doing any database operations here. If you global &dollar;phpgw_setup, you will then have access to db and schema_proc objects and functions. The objects of interest here are:
    </para>
    <itemizedlist>
     <listitem>
     <para>
     &dollar;phpgw_setup-&gt;oProc
     </para>
    </listitem>
     <listitem>
     <para>
     &dollar;phpgw_setup-&gt;db.
     </para>
    </listitem>
    </itemizedlist>
    <para>
     For most database work you should use the oProc object. This also has a db object that should be used for most standard phpgw API db class functions, including &dollar;db-&gt;query, next_record, num_rows, and f. The use of these for standard db operations is critical to the upgrade process. Schema_proc has a flag that can be set to determine what mode of upgrade we are in. This flag is set in the setup class during the upgrade process, and should not be altered locally.
    </para>
    <para>
     This flag is a decision on whether to alter the database or the schema_proc array. The tables_baseline file above is loaded by setup prior to running your upgrade routines. If the current installed version is greater than the current upgrade routine, we don't need to alter the database yet. But schema_proc instead alters the &dollar;phpgw_baseline array in memory. The maintenance of this array is done even when we do alter the database. Once our version number in the test array matches the currently installed version of an application, real work on the tables begins.
    </para>
    <para>
     'Why bother modifying this array at all', you may ask. The array must be maintained in order to keep current table definition status. This is used in some schema_proc functions when altering columns and tables. This is especially critical for pgsql schema_proc functions.
    </para>
    <para>
     By using the &dollar;phpgw_setup-&gt;oProc object for basic inserts and queries, we acheive the ability to run all upgrade functions in every upgrade cycle without actually altering the database until we reach the current version we actually want to upgrade. For example:
    </para>
    <programlisting>
<![ CDATA [$sql = "SELECT * FROM phpgw_addressbook_extra WHERE contact_name='notes'";
]]><![ CDATA [$phpgw_setup->oProc->query($sql,__LINE__,__FILE__);
]]><![ CDATA [while($phpgw_setup->oProc->next_record()) {
]]>    </programlisting>
    <para>
     We could have used &dollar;phpgw_setup-&gt;db or even a copy for the above activity. However, using the above method ensures that an array only upgrade does just that. If the flag was set in setup telling schema_proc to alter the array only, we do not want to touch the tables for inserts or selects yet. In this case, &dollar;phpgw_setup-&gt;oProc-&gt;next_record() returns False, and the loop is skipped. The &dollar;phpgw_baseline array does not know about table content, only table and field definitions.
    </para>
    <para>
     If the upgrade function containing this method is actually working on the tables (currentver &lt;= the upgrade function), then next_record() is returned as the expected action of pulling the next row of data. Inside of this while loop, you can safely use &dollar;phpgw_setup-&gt;db, or preferably a copy, to do the insert/delete, etc you want to have happen here.
    </para>
    <programlisting>
<![ CDATA [    $cid = $phpgw_setup->oProc->f('contact_id');
]]><![ CDATA [    $cvalu = $phpgw_setup->oProc->f('contact_value');
]]><![ CDATA [    $update = "UPDATE phpgw_addressbook set note='" . $cvalu . "' WHERE id=" . $cid;
]]><![ CDATA [    $db1->query($update);
]]><![ CDATA [    $delete = "DELETE FROM phpgw_addressbook_extra WHERE contact_id=" . $cid . " AND contact_name='notes'";
]]><![ CDATA [    $db1->query($delete);
]]><![ CDATA [}
]]>    </programlisting>
    <para>
     &dollar;db1 is a copy of &dollar;phpgw_setup-&gt;db, to avoid potential conflicts with the rest of setup's db activities.
    </para>
    <para>
     In addition to the basic API db class functions, schema_proc introduces the following special functions:
    </para>
    <programlisting>
<![ CDATA [function DropTable($sTableName)
]]><![ CDATA [function DropColumn($sTableName, $aTableDef, $sColumnName)
]]><![ CDATA [function RenameTable($sOldTableName, $sNewTableName)
]]><![ CDATA [function RenameColumn($sTableName, $sOldColumnName, $sNewColumnName)
]]><![ CDATA [function AlterColumn($sTableName, $sColumnName, $aColumnDef)
]]><![ CDATA [function AddColumn($sTableName, $sColumnName, $aColumnDef)
]]><![ CDATA [function CreateTable($sTableName, $aTableDef)
]]>    </programlisting>
    <para>
     Please use these functions where appropriate in place of standard SQL CREATE, DROP, and ALTER TABLE commands. This will ensure that your upgrade script works for all supported databases.
    </para>
    <para>
     Of these functions, DropTable, RenameTable, and RenameColumn are pretty straightforward. Pass these the table names you wish to Drop/Rename, and schema_proc will handle the rest, including indexes and sequences, where applicable.
    </para>
    <para>
     The remaining functions require some explanation:
    </para>
    <itemizedlist>
     <listitem>
     <para>
     CreateTable:
     </para>
    </listitem>
    </itemizedlist>
    <programlisting>
<![ CDATA [$phpgw_setup->oProc->CreateTable(
]]><![ CDATA [    'categories', array(
]]><![ CDATA [        'fd' => array(
]]><![ CDATA [            'cat_id' => array('type' => 'auto','nullable' => false),
]]><![ CDATA [            'account_id' => array('type' => 'int','precision' => 4,'nullable' => false, 'default' => 0),
]]><![ CDATA [            'app_name' => array('type' => 'varchar','precision' => 25,'nullable' => false),
]]><![ CDATA [            'cat_name' => array('type' => 'varchar', 'precision' => 150, 'nullable' => false),
]]><![ CDATA [            'cat_description' => array('type' => 'text', 'nullable' => false)
]]><![ CDATA [        ),
]]><![ CDATA [        'pk' => array('cat_id'),
]]><![ CDATA [        'ix' => array(),
]]><![ CDATA [        'fk' => array(),
]]><![ CDATA [        'uc' => array()
]]><![ CDATA [    )
]]><![ CDATA [);
]]>    </programlisting>
    <para>
     Does this look familiar? The array passed to CreateTable is in the format used also in tables_baseline and tables_current. Note a slight difference where the table name is being passed as a seperate argument. The second argument to the function is the table definition array, starting with 'fd'.
    </para>
    <itemizedlist>
     <listitem>
     <para>
     AddColumn:
     </para>
    </listitem>
    </itemizedlist>
    <programlisting>
<![ CDATA [$phpgw_setup->oProc->AddColumn('phpgw_categories','cat_access',array('type' => 'varchar', 'precision' => 25));
]]>    </programlisting>
    <para>
     Here we pass the table name of an existing table, the new column name, and a field definition. This definition is merely a slice of the table arrays found earlier in this document.
    </para>
    <itemizedlist>
     <listitem>
     <para>
     AlterColumn:
     </para>
    </listitem>
    </itemizedlist>
    <programlisting>
<![ CDATA [$phpgw_setup->oProc->AlterColumn('phpgw_sessions','session_action',array('type' => 'varchar', 'precision' => '255'));
]]>    </programlisting>
    <para>
     The format of this function matches AddColumn. It is also a simple case of passing the table name, field name, and field definition.
    </para>
    <itemizedlist>
     <listitem>
     <para>
     DropColumn:
     </para>
    </listitem>
    </itemizedlist>
    <programlisting>
<![ CDATA [$newtbldef = array(
]]><![ CDATA [    "fd" => array(
]]><![ CDATA [        'acl_appname' => array('type' => 'varchar', 'precision' => 50),
]]><![ CDATA [        'acl_location' => array('type' => 'varchar', 'precision' => 255),
]]><![ CDATA [        'acl_account' => array('type' => 'int', 'precision' => 4),
]]><![ CDATA [        'acl_rights' => array('type' => 'int', 'precision' => 4)
]]><![ CDATA [    ),
]]><![ CDATA [    'pk' => array(),
]]><![ CDATA [    'ix' => array(),
]]><![ CDATA [    'fk' => array(),
]]><![ CDATA [    'uc' => array()
]]><![ CDATA [);
]]><![ CDATA [$phpgw_setup->oProc->DropColumn('phpgw_acl',$newtbldef,'acl_account_type');
]]>    </programlisting>
    <para>
     This is the most complicated function in schema_proc, from the user's perspective. Its complexity is necessitated by the requirement of some databases to recreate a table in the case of dropping a column. Note that the table definition array is being used yet again. The array defined here should match the table definition you want after this function has completed. Here, we are dropping the column 'acl_account_type' from the table 'phpgw_acl', and the table definition does not have this column defined. You could copy information from your tables_current file here and edit it to match the desired new table spec, less the column you wish to drop.
    </para>
    <para>
     There are additional functions within schema_proc, the majority of which are not to be called directly. They are used internally. If you do wish to investigate further, use class.schema_proc.inc.php as your guide. This master file includes the class.schema_proc_DBMS.inc.php and class.schema_proc_array.inc.php files. The DBMS files should not be used as a guide, since their functions are called from the master class, and the parameters are different from what you might expect relative to the master.
    </para>
    <para>
     PLEASE, DO NOT WRITE TO OR ALTER ANOTHER APPLICATION'S TABLES OR THE API TABLES IN YOUR APPLICATION UPGRADE FUNCTIONS!
    </para>
    </sect3>
   </sect2>
   <sect2>
    <title>
    default_records.inc.php (Optional)
   </title>
    <sect3>
     <title>
     Any application with tables that wants to load some default data will need this file.
    </title>
    <para>
     The default_records file consists of a list of SQL INSERTs using the &dollar;oProc object directly:
    </para>
    <programlisting>
<![ CDATA [$oProc->query("INSERT INTO phpgw_inv_statuslist (status_name) VALUES ('available')");
]]><![ CDATA [$oProc->query("INSERT INTO phpgw_inv_statuslist (status_name) VALUES ('no longer available')");
]]><![ CDATA [$oProc->query("INSERT INTO phpgw_inv_statuslist (status_name) VALUES ('back order')");
]]>    </programlisting>
    <para>
     In this case, the developer wanted to insert some status information, which was then used in a select box on an html form. Using the default_records file, every new install will have this data included. This file should consist of queries applicable to the tables defined in setup.inc.php and tables_current.inc.php.
    </para>
    </sect3>
   </sect2>
   <sect2>
    <title>
    test_data.inc.php (Optional)
   </title>
    <sect3>
     <title>
     Any developer wanting to test the full list of upgrade routines can use this file.
    </title>
    <para>
     test_data.inc.php is similar to default_records above. It is called only by schematoy.php and is never installed with a new install or upgrade. This is a developer-only file. The INSERTs here should be applicable to the tables_baseline table definitions.
    </para>
    </sect3>
   </sect2>
   <sect2>
    <title>
    language files (Required)
   </title>
    <sect3>
     <title>
     All applications should have at least a file of English translations, used for their application lang() calls.
    </title>
    <itemizedlist>
     <listitem>
     <para>
     Format of a lang file:
     </para>
    </listitem>
    </itemizedlist>
    <programlisting>
<![ CDATA [{phrase}{TAB}{appname}{TAB}{LANG_CODE}{TAB}{translation}
]]><![ CDATA [    e.g:
]]><![ CDATA [first name    common    en    First Name
]]><![ CDATA [first name    common    de    Vorname
]]>    </programlisting>
    <itemizedlist>
     <listitem>
     <para>
     Filenames:
     </para>
    </listitem>
    </itemizedlist>
    <programlisting>
<![ CDATA [phpgw_{LANG_CODE}.lang
]]><![ CDATA [  e.g.
]]><![ CDATA [English: phpgw_en.lang
]]><![ CDATA [German: phpgw_de.lang
]]>    </programlisting>
    <para>
     Please see the contents of the API 'languages' table for the correct setting of the LANG_CODE.
    </para>
    </sect3>
   </sect2>
  </sect1>
  <sect1>
   <title>
   Developer Tools
  </title>
   <sect2>
    <title>
    sqltoarray.php
   </title>
    <sect3>
     <title>
     Displays the current schema_proc array defining an application's tables.
    </title>
    <para>
     This web application reads the current table status live from the database. It then parses this information into a hopefully correct table definition array for schema_proc. Upon visiting this app, you are shown a list of currently installed applications with defined tables. You may then select one app or all apps, and then submit the form. From this form you may then download a tables_current file, suitable for commission to cvs. Please do check the format to make sure the definitions are correct.
    </para>
    </sect3>
   </sect2>
   <sect2>
    <title>
    schematoy.php
   </title>
    <sect3>
     <title>
     Runs the full cycle of upgrades, including optional test_data.
    </title>
    <para>
     This app is not beautiful, may bomb on you, and will definitely drop your application's tables. The display is similar to the user/admin tool, applications.php. You are shown a list of apps with tables. Select one app, and enter a target version. Upon submission of the form:
    </para>
    <itemizedlist>
     <listitem>
     <para>
     All application tables are dropped.
     </para>
    </listitem>
     <listitem>
     <para>
     tables_baseline.inc.php is loaded.
     </para>
    </listitem>
     <listitem>
     <para>
     test_data.inc.php is loaded
     </para>
    </listitem>
     <listitem>
     <para>
     tables_update.inc.php is loaded.
     </para>
    </listitem>
     <listitem>
     <para>
     a full application upgrade test begins.
     </para>
    </listitem>
    </itemizedlist>
    <para>
     This will give a LOT of debugging output. Depending on your database, the process may take quite awhile. This tool should be considered as a destructive test of the full upgrade cycle. If the upgrade process is successful, you can then check the loaded test_data to see that it is still in place as expected after all the table modifications, etc. If not, it should be clear where the error has occurred. Look for the usual INVALID SQL warnings, among others.
    </para>
    </sect3>
   </sect2>
   <sect2>
    <title>
    tools subdirectory
   </title>
    <sect3>
     <title>
     some utilities for sql file conversion, etc.
    </title>
    <para>
     In the tools directory under setup3, there should be at least a couple of hopefully handy perl or shell scripts. These are for running on the commandline only, and might apply to converting SQL files into lang files, etc. They are not expected to be perfect, but might offer some assistance or ideas for additional utilities. Use these at your own risk or benefit.
    </para>
    </sect3>
   </sect2>
  </sect1>
  <sect1>
   <title>
   The install/upgrade process
  </title>
   <sect2>
    <title>
    Overview
   </title>
    <sect3>
     <title>
     Setup internal upgrade functions
    </title>
    <para>
     Setup uses a common set of functions for new installs and upgrades. These are implemented as multi-pass loops. For a single application install or upgrade, a single pass is done. For multiple application installs or upgrades, multiple passes are done automatically. The order of install in a mass install or upgrade is determined by application dependencies. The other determining factor is the order in which the application directories and setup.inc.php files are read from the filesystem.
    </para>
    </sect3>
   </sect2>
   <sect2>
    <title>
    New installs
   </title>
    <sect3>
     <title>
     Detection
    </title>
    <para>
     Each run of index.php or applications.php in setup3 first runs a set of detection routines. These read the data from each setup.inc.php file, and from the 'applications' or 'phpgw_applications' table as appropriate, and only if one of these tables exists. This data is parsed into the &dollar;setup_info array. In this case, this array contains information about all applications. Based on the information gathered, a status flag is set to one of the following values:
    </para>
    <itemizedlist>
     <listitem>
     <para>
     U - Upgrade required/available
     </para>
    </listitem>
     <listitem>
     <para>
     R - upgrade in pRogress
     </para>
    </listitem>
     <listitem>
     <para>
     C - upgrade Completed successfully
     </para>
    </listitem>
     <listitem>
     <para>
     D - Dependency failure
     </para>
    </listitem>
     <listitem>
     <para>
     F - upgrade Failed
     </para>
    </listitem>
     <listitem>
     <para>
     V - Version mismatch at end of upgrade
     </para>
    </listitem>
     <listitem>
     <para>
     M - Missing files at start of upgrade (Not used, proposed only)
     </para>
    </listitem>
    </itemizedlist>
    <para>
     Using this information, the setup logic in index.php determines what mode we are in. index.php is not capable of being selective about which application it found as being out of sync. It is designed only for 'Simple Application Management', which is Step 1 of the setup process. For more selective application manipulation, use applications.php. index.php then tells the user that 1) their applications are current 2) some of their applications are out of sync 3) no db exists, etc. For a new install, all applications will be out of sync, since there is not even an 'phpgw_applications' table in the database to tell setup what the status is for any application.
    </para>
    </sect3>
    <sect3>
     <title>
     Selection
    </title>
    <para>
     There is no selection for application installs in 'new install' mode. All physically present applications will be installed, or at least attempted.
    </para>
    </sect3>
    <sect3>
     <title>
     Installation
    </title>
    <para>
     Once the setup user clicks the magic button to install all applications, the following occurs:
    </para>
    <itemizedlist>
     <listitem>
     <para>
     The setup_info array is passed to the process_pass() function, using a method='new'
     </para>
    </listitem>
     <listitem>
     <para>
     Applications whose status flag='U' (API on first pass) are then handed off to the process_current() function. This handles inclusion and installation of the application's tables_current.inc.php file.
     </para>
    </listitem>
     <listitem>
     <para>
     The application is registered as a new application in the 'phpgw_applications' table. If for some reason there is old data in this table for this application, it will be updated instead. Its hooks, if any, are registered in the 'phpgw_hooks' table.
     </para>
    </listitem>
     <listitem>
     <para>
     Next, this array is passed to the process_default_records() function. If this file is present in the current application's setup directory, the queries here are run to install the data to the application's table(s).
     </para>
    </listitem>
     <listitem>
     <para>
     The above is repeated until all application status flags equal 'C'. However, if an application install failed for some reason, it will then be skipped on the next pass. This keeps the loop from running away.
     </para>
    </listitem>
    </itemizedlist>
    </sect3>
   </sect2>
   <sect2>
    <title>
    Upgrades
   </title>
    <sect3>
     <title>
     Detection
    </title>
    <para>
     Only an API version mismatch will trigger an automated request for the user to upgrade their install. Once the api is current, they can move on to applications.php for more 'Advanced Application Management', which is Step 4 of the setup process. However, if the API is out of sync, clicking 'Upgrade' in index.php will also attempt to upgrade other applications which may be out of sync, as well. As the phpgwapi continues to stabilize, it is felt that this method of upgrading will become less and less common.
    </para>
    </sect3>
    <sect3>
     <title>
     Selection
    </title>
    <para>
     Within applications.php, a color-coded matrix of application status and actions is displayed. Depending on the status flag of each application, certain actions will be either enabled or disabled. These actions include 'install', 'upgrade', 'remove'. If something is very wrong with previous attempts to install or upgrade an application, another column called 'resolution' will then display a link. This link will display additional information which would be helpful for determining how to resolve the problem. Assuming all is well, the user can select applications requiring upgrade from this list. Once selected, they submit the form. This runs the follow three routines in order:
    </para>
    <itemizedlist>
     <listitem>
     <para>
     remove
     </para>
    </listitem>
     <listitem>
     <para>
     install
     </para>
    </listitem>
     <listitem>
     <para>
     upgrade
     </para>
    </listitem>
    </itemizedlist>
    </sect3>
    <sect3>
     <title>
     Upgrade
    </title>
    <para>
     The idea here is that multiple actions can be selected and run in order in one click. In any case, once they select an application for upgrade, the following occurs:
    </para>
    <itemizedlist>
     <listitem>
     <para>
     A stripped down version of the setup_info array is passed to the process_upgrade() function. This array contains only the information for the selected application
     </para>
    </listitem>
     <listitem>
     <para>
     Within process_upgrade(), the tables_baseline.inc.php file for the application is loaded.
     </para>
    </listitem>
     <listitem>
     <para>
     The tables_update.inc.php file for the application is loaded
     </para>
    </listitem>
     <listitem>
     <para>
     The contents of the test array is used to loop through the entire list of upgrade functions for the application. The application's unique function names are rebuilt, then run.
     </para>
    </listitem>
     <listitem>
     <para>
     When the currentver (installed) matches the version (available), process_upgrade() exits, setting the status flag for the app to 'C'.
     </para>
    </listitem>
     <listitem>
     <para>
     Just prior to exiting, the application and its hooks are updated into the 'phpgw_applications' and 'phpgw_hooks' tables.
     </para>
    </listitem>
    </itemizedlist>
    </sect3>
   </sect2>
   <sect2>
    <title>
    Uninstallation/Removal
   </title>
    <sect3>
     <title>
     Selection
    </title>
    <para>
     Selective removal of an application is done via applications.php, in a manner similar to the method above for upgrades.
    </para>
    </sect3>
    <sect3>
     <title>
     Uninstallation
    </title>
    <para>
     Once an application is selected for removal:
    </para>
    <itemizedlist>
     <listitem>
     <para>
     A stripped down version of the setup_info array is passed to the process_droptables() function. This function removes all of the application's defined tables, but only after first checking to see if the tables are there. In this way, we attempt to cut down on the number of errors sent to the browser.
     </para>
    </listitem>
     <listitem>
     <para>
     The application's hooks are deregistered (removed from 'phpgw_hooks').
     </para>
    </listitem>
     <listitem>
     <para>
     The application itself is deregistered (removed from 'phpgw_applications').
     </para>
    </listitem>
    </itemizedlist>
    </sect3>
   </sect2>
  </sect1>
  <sect1>
   <title>
   Caveats
  </title>
   <sect2>
    <title>
    Must see info
   </title>
    <sect3>
     <title>
     Auto fields
    </title>
    <para>
     For auto type fields, schema_proc creates a sequence automatically based on the table name for databases that require sequences. In the case of postgresql, the limit for this name based on our tests is 31 characters. The schema_proc format is:
    </para>
    <programlisting>
<![ CDATA [$sSequenceSQL = sprintf("CREATE SEQUENCE seq_%s", $sTableName);
]]>    </programlisting>
    <para>
     This limits the maximum length for a tablename to 27 characters. Based on the tablename standard in phpgw of 'phpgw_tablename', you are further limited to 21 characters in which to describe your table. You will need to be less descriptive in some cases, e.g. use 'phpgw_widget_cats' instead of 'phpgw_widget_info_categories'.
    </para>
    <para>
     To maintain compatibility with MySQL 3.22.X, please always add &ldquo;'nullable' =&gt; False&rdquo; to your field spec for an auto field. This and probably older versions of MySQL require that specification within the SQL for a field that will also be an index or unique field, which for our uses should typically be true for an auto field. MySQL 3.23.X and PostgreSQL do not have this issue.
    </para>
    </sect3>
    <sect3>
     <title>
     Default 0
    </title>
    <para>
     For int fields, a default of 0 is not assumed. Only some databases will set this default for you, MySQL being one. You will need to explicitly define this default in the table definition. Also, for auto fields, do not enter a default, since the resulting SQL query would fail on many RDBMS.
    </para>
    </sect3>
   </sect2>
  </sect1>


</article>
